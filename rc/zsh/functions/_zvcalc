# -*- mode: shell-script; sh-shell: zsh; fill-column: 75; comment-column: 50; coding: utf-8 -*-

emulate -L zsh

function {
    local PROMPT4 PS4="; "
    local expr
    local -a oexpr
    local numpat='(([0-9]+|[0-9]{1,3}((,[0-9]{3})+|(_[0-9]{3})+))([.][0-9]+)?)'

    # Handle simple base-conversions w/ `rax2`
    if [[ "$*" =~ "^(-[a-zA-Z] |=[0-9]+ )?[oO]?[t0-9a-fA-Fx.]+[oO]?$" ]]; then
        { setopt xtrace; rax2 "$@" }
    else

        # match function-like expressions, e.g `sqrt 5+3`
        if [[ "$#" -gt 1 && "$1" =~ "^[a-z]+$" && ! "$2" =~ "^[({[{]" ]]; then
            local pfix="$1"
            shift

            while (( $# )); do
                if [[ "$1" =~ "^$numpat$" ]]; then
                    oexpr+=("${1//,/}")

                    # Separate numeric arguments with a comma
                    # e.g `sum 1 2 3` => `sum(1,2,3)`
                    if [[ "$2" =~ "^[0-9]+(,[0-9]{3})*$" ]]; then
                        oexpr+=(',')
                    fi
                else
                    oexpr+=("$1")
                fi

                shift
            done

            print -v expr -f "%s(%s)" -- "$pfix" "${(j::)oexpr}"

        # match arithmetic expressions e.g `2+2`, `1_000/5.25`, `1,000 * 5`
        elif [[ "$*" =~ "^($numpat ?[^,_.A-Za-z0-9]+ ?)+$numpat$" ]]; then
            print -v expr -f "%s" -- "${${*//,/}//_/}"

        # otherwise, use the expression as-is
        else
            print -v expr -f "%s" -- "$*"
        fi

        # Make sure double-quotes are escaped
        { setopt xtrace; emacsclient -e "(calc-eval \"$expr\")" } | perl -wple 's/^"|"$//g'
    fi
} "$@"
