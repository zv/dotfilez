# -*- mode: shell-script; sh-shell: zsh; fill-column: 75; comment-column: 50; coding: utf-8 -*-

emulate -L zsh

function {
    local PROMPT4 PS4="; "

    # Handle simple base-conversions w/ `rax2`
    if [[ "$*" =~ "^(-[a-zA-Z] |=[0-9]+ )?[oO]?[t0-9a-fA-Fx.]+[oO]?$" ]]; then
        { setopt xtrace; rax2 "$@" }
    else
        local fmt
        # If the first word is alphanumeric, assume it's a function call
        # e.g `sqrt 5+3` => `sqrt(5+3)`
        if [[ "$#" -gt 1 && "$1" =~ "^[a-z]+$" && ! "$2" =~ "^[({[{]" ]]; then
            fmt="(calc-eval \"$1(%s)\")"
            shift
        else
            fmt='(calc-eval "%s")'
        fi

        local -a oexpr
        local csepnum_pat="^([0-9]+,)*[0-9]+$"
        while (( $# )); do
            if [[ "$1" =~ "$csepnum_pat" ]]; then
                oexpr+=("${1//,/}")
                # Separate numeric arguments with a comma
                # e.g `sum 1 2 3` => `sum(1,2,3)`
                if [[ "$2" =~ "$csepnum_pat" ]]; then
                    oexpr+=(',')
                fi
            else
                oexpr+=("$1")
            fi
            shift
        done

        local expr
        print -v expr -f "$fmt" -- "${(j::)oexpr}"

        # Make sure double-quotes are escaped
        { setopt xtrace; emacsclient -e "$expr" } | perl -wple 's/^"|"$//g'
    fi
} "$@"
