# -*- mode: shell-script; sh-shell: zsh; fill-column: 75; comment-column: 50; coding: utf-8 -*-

emulate -L zsh

local PROMPT4 PS4="; "

# Handle simple base-conversions w/ `rax2`
if [[ "$*" =~ "^(-[a-zA-Z] |=[0-9]+ )?[oO]?[t0-9a-fA-Fx.]+[oO]?$" ]]; then
    { setopt xtrace; rax2 "$@" }
else
    local cmd
    local expr
    local number='(([0-9]+|[0-9]{1,3}((,[0-9]{3})+|(_[0-9]{3})+))([.][0-9]+)?)'

    # match function-like expressions, e.g `sqrt 5+3`
    if [[ "$1" =~ '^[a-z]+$' && "$2" =~ '^[^({[{]' ]]; then
        local calc_cmd="$1"
        shift

        local -a oexpr
        while (( $# )); do
            if [[ "$1" =~ "^$number$" ]]; then
                oexpr+=("${1//,/}")

                # Separate numeric arguments with a comma
                # e.g `sum 1 2 3` => `sum(1,2,3)`
                if [[ "$2" =~ "^$number$" ]]; then
                    oexpr+=(',')
                fi
            else
                oexpr+=("$1")
            fi

            shift
        done

        print -v expr -f "%s(%s)" -- "$calc_cmd" "${(j::)oexpr}"

    # match arithmetic expressions e.g `2+2`, `1_000/5.25`, `1,000 * 5`
    elif [[ "$*" =~ "^($number ?[^,_.A-Za-z0-9]+ ?)+$number$" ]]; then
        print -v expr -f "%s" -- "${${*//,/}//_/}"

    # otherwise, use the expression as-is
    else
        print -v expr -f "%s" -- "$*"
    fi

    print -v cmd -f '(calc-eval "%s")' -- "$expr"

    # Make sure double-quotes are escaped
    { setopt xtrace; emacsclient -e "$cmd" } | perl -wple 's/^"|"$//g'
fi
