[user]
	name       = zv
	email      = zephyr.pellerin@gmail.com
	editor     = vim
	signingkey = 0xF6F2D0445DC172F8

[github]
	user = zv

[core]
	editor = vim
	excludesfile = ~/.gitignore
	whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
	safecrlf = true
	autocrlf = input

[commit]
	verbose = true
	gpgsign = true

[gpg]
	program = gpg2

[color]
	pager       = true
	ui          = true

[grep]
	lineNumber = true
	threads = 4
	extendedRegex = true

[color "diff"]
	meta = yellow bold
	frag = magenta bold
	old = red
	new = green
	whitespace = red reverse

[color "status"]
	added     = green
	changed   = yellow
	untracked = red
	nobranch  = red reverse

[log]
	date = short

[apply]
	whitespace = nowarn

[diff]
	# Git diff will use (i)ndex, (w)ork tree, (c)ommit and (o)bject
	# instead of a/b/c/d as prefixes for patches
	mnemonicprefix = true
	tool           = vimdiff

[difftool]
	prompt = false

[merge]
	summary = true
	verbosity = 1
	tool = vimdiff3

[mergetool "ediff"]
	cmd = "emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\""

[advice]
	statusHints = false

[push]
	default = current

[rebase]
	stat = true

[rerere]
	enabled = false

[alias]
	# ── Git Alias Help ─────────────────────────────────────────
	#
	#   * <https://git.wiki.kernel.org/index.php/Aliases>
	#   * <http://stackoverflow.com/questions/267761/what-does-your-gitconfig-contain>
	#   * <http://superuser.com/questions/169695/what-are-your-favorite-git-aliases>
	#   * <http://stackoverflow.com/questions/1309430/how-to-embed-bash-script-directly-inside-a-git-alias>
	#   * <http://code.joejag.com/2013/everyday-git-aliases/>
	#   * <http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/>
	#   * <https://ochronus.com/git-tips-from-the-trenches/>
	#   * <http://mislav.uniqpath.com/2010/07/git-tips/>

	# ── Short aliases ──────────────────────────────────────────

	# add - record file contents to the index.
	a = add

	# branch - list, create, or delete branches.
	b = branch

	# commit - record changes to the repostiory.
	c = commit

	# diff - show changes between commits, commit and working tree, etc.
	d = diff

	# fetch - download objects and refs from another repository.
	f = fetch

	# grep - print lines matching a pattern.
	g = grep

	# log - show commit logs.
	l = log --date=format:\"%m/%d/%y\" --pretty=\"format:%C(auto)%<(8)%h%Creset| %C(blue)%ad%Creset | %C(013)%><(15,trunc)%aN%Creset |%C(auto)%d%Creset %s\" --abbrev-commit

	# merge - join two or more development histories together.
	m = merge

	# checkout - update the working tree to match a branch or paths; we use "o" to mean "out".
	o = checkout

	# pull - fetch from and merge with another repository or a local branch.
	p = pull

	# remote - manage set of tracked repositories.
	r = remote

	# status - show the working tree differences. (Expert users may prefer: status -sb)
	s = status

	# whatchanged - show logs with the differences introduced by each commit.
	w = whatchanged

	# add just the files in the local directory that are updated.
	au = add --update .

	# add by patch then commit - looks at each change, and asks if we want to put it in the repo, then commits.
	ac = !"git add --patch; git commit"

	# add by patch - looks at each change, and asks if we want to put it in the repo.
	ap = add --patch

	# branch - edit the description
	be = branch --edit-description

	# branch - list, create, or delete branches [same as "b"]
	br = branch

	# branch and only list branches whose tips are reachable from the specified commit (HEAD if not specified).
	brm = branch --merged

	# branch and only list branches whose tips are not reachable from the specified commit (HEAD if not specified).
	brnm = branch --no-merged

	# commit - amend the tip of the current branch rather than creating a new commit.
	ca = commit --amend

	# commit interacively
	ci = commit --interactive

	# commit with a message
	cm = commit --message

	# checkout - update the working tree to match a branch or paths. [same as "o" for "out"]
	co = checkout

	# cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
	cp = cherry-pick

	# cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
	cp-nx = cherry-pick --no-commit -x

	# diff - show changes not yet staged
	dc = diff --cached

	# diff - changes about to be commited
	# diff - show changes but by word, not line
	dw = diff --word-diff

	# log with a text-based graphical representation of the commit history.
	lg = log --graph

	# log with one line per item.
	lo = log --oneline
	lol  = log --graph --decorate --pretty=oneline --abbrev-commit
	lola  = log --graph --decorate --pretty=oneline --abbrev-commit --all

	# log with patch generation.
	lp = log --patch

	# log with items appearing in topological order, i.e. descendant commits are shown before their parents.
	lt = log --topo-order

	# log key - our favorite way to show our key performance indicators, i.e. our most useful summary.
	lk = log --graph --topo-order --abbrev-commit --date=short --decorate --all --boundary --pretty=format:'%Cblue%ad %C(yellow)%h%Creset -%C(red)%d%Creset %s %C(013)[%cn]%Creset'

	# ls-files - show information about files in the index and the working tree; like Unix "ls" command.
	ls = ls-files

	# ls-ignored -  list files that git has ignored.
	ls-ignored = ls-files --others --i --exclude-standard

	# Decorate with branches
	ll = log --graph --oneline --decorate --branches --tags

	# A shortcut for seeing the fetched commits
	lc = log ORIG_HEAD.. --stat --no-merges

	# Show signatures
	lsig = log  --pretty=format:\"%C(blue)%ad%  %C(yellow)%h%C(red)%d%Creset %s %C(013)%C(bold) %m %an [%G?] %GS %GK %Creset\"

	# Log changes
	changes = log --pretty=format:\"%C(yellow)%h%C(reset) %C(blue)%cr%Creset %C(013)%cn%Creset - %s\" --name-status

	# Shortlog
	short = log --pretty=format:'%C(yellow)%h%Creset - %<(80,trunc)%s %<(20) %cn %cr '
	changelog = log --pretty=format:\" * %s\"

	# merge but without autocommit, and with a commit even if the merge resolved as a fast-forward.
	me = merge --no-commit --no-ff

	# pull with rebase - to provide a cleaner, linear, bisectable history.
	pr = pull --rebase
	pro = !"git pull --rebase origin $(git symbolic-ref HEAD)"

	# Show our branches as a tree
	prtree  = log --graph --simplify-by-decoration --pretty=format:'%d' --all

	# rbi
	rbi = !"git rebase -i @{u}"

	# Copy format of ripgrep
	rg = "grep --heading --break -i"

	# reflog - reference log that manages when tips of branches are updated.
	rl = reflog

	# remote - manage set of tracked repositories [same as "r"].
	rr = remote

	# remote show - gives some information about the remote <name>.
	rrs = remote show

	# remote update - fetch updates for a named set of remotes in the repository as defined by remotes.
	rru = remote update

	# remote prune - deletes all stale remote-tracking branches under <name>.
	rrp = remote prune

	# revert - undo the changes from some existing commits
	rv = revert

	# revert without autocommit; useful when you're reverting more than one commits' effect to your index in a row.
	rvnc = revert --no-commit

	# show-branch - print a list of branches and their commits.
	sb = show-branch

	# submodule - enables foreign repositories to be embedded within a dedicated subdirectory of the source tree.
	sm = submodule

	# submodule with initialize, update, and recursive; this is useful to bring a submodule fully up to date.
	smu = submodule update --init --recursive

	# status - short summary instead of full details
	ss = status --short

	# status - show the working tree differences [same as "s"]
	st = status

	# ── Inspection Aliases ─────────────────────────────────────

	# Show our defined aliases
	aliases = !"git config --get-regexp 'alias.*' | colrm 1 6 | sed 's/[ ]/ = /'"

	# Show our tags
	tags = tag -n1 -l

	# Diffs
	diff-all = !"for name in $(git diff --name-only $1); do git difftool $1 $name & done"
	diff-changes = diff --name-status -r
	diff-stat = diff --stat -b -r
	diff-staged = diff --cached

	# From https://gist.github.com/492227
	head = !"git log -n1"
	heads = !"git log origin/master.. --format='%Cred%h%Creset;%C(yellow)%an%Creset;%H;%Cblue%f%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"
	lost = !"git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset %f' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"

	# Search git history for text
	grep-all = !"git rev-list --all | xargs git grep --color=auto -a $@"

	# Search git history for a filename
	locate-all = "!git log --all --pretty=oneline --full-history -- **/$@"

	# Find all objects that aren't referenced by any other object (orphans).
	orphans = fsck --full

	# ── Log Aliases ───────────────────────────────────────

	log-graph = log --all --graph --decorate
	log-timeline = log --format='%h %an %ar - %s'
	log-local = log --oneline origin..HEAD
	log-timeline = log --date=local --format='%h %an %ar - %s'
	log-fetched = log --oneline HEAD..origin/master

	# Show log of changes, most recent first
	log-changes = log --oneline --reverse

	# Show log of new commits after you fetched, with stats, excluding merges
	log-commits = log ORIG_HEAD.. --stat --no-merges

	# Show log with dates in our local timezone
	log-local = log --date=local

	# Show the log for my own user email
	log-me = !git log --author $(git config user.email)

	# Show log as a graph
	log-graph = log --graph --oneline --decorate

	# Show the date of the first commit
	log-first-date = !"git log --date-order --date=iso --pretty='%ad' --reverse | head -1"

	# Show the recent day
	log-day = log --since yesterday
	log-refs = log --all --graph --decorate --oneline --simplify-by-decoration --no-merges

	# Summarize your own changes since yesterday, suitable for a daily standup meeting.
	log-standup = !git log --since yesterday --pretty=short --author $(git config user.email)

	# churn: show log of files that have many changes
	churn = !git log --all -M -C --name-only --format='format:' "$@" | sort | grep -v '^$' | uniq -c | sort | awk 'BEGIN {print "count", "file"} {print $1, $2}' | sort -g

	# ── Lookup aliases ────────────────────────────────────

	# whois: given a string for an author, try to figure out full name and email:
	whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>\n\" --author=\"$1\"' -"

	# Given any git object, try to show it briefly
	whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short

	# Show who contributed with summarized changes
	who = shortlog -s --

	# Show who contributed, in descending order by number of commits
	whorank = shortlog -sn --no-merges

	# Stash aliases
	save = !git stash save
	pop = !git stash pop

	# Stash snapshot - from http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
	# This is handy for refactoring where you can’t quite fit what you’ve done
	# into a commit but daren’t stray too far from now without a backup.
	snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"

	# When you're a little worried that the world is coming to an end
	panic = !tar cvf ../git_panic.tar *

	# Do everything we can to synchronize all changes
	get = !git pull --rebase && git submodule update --init --recursive
	put = !git commit -am "$1" && git push

	# Undo aliases
	undo = reset --hard
	undoclean = !git reset --hard && git clean -fd
	uncommit = reset --soft HEAD^
	unadd = reset HEAD
	unstage = reset HEAD

	# Editing and adding conflicted files: when we get many merge conflicts
	# and want to quickly solve them using an editor, then add the  files.
	edit-unmerged = !"f() { git ls-files --unmerged | cut -f2 | sort -u ; }; $EDITOR `f`"
	add-unmerged = !"f() { git ls-files --unmerged | cut -f2 | sort -u ; }; git add `f`"

	# Ours & Theirs - easy merging when you know which files you want
	ours   = !"f() { git checkout --ours $@ && git add $@; }; f"
	theirs = !"f() { git checkout --theirs $@ && git add $@; }; f"

	# Work In Progress: from https://gist.github.com/492227 and VonC on stackoverflow.
	# This enables a quick way to add all new and modified files to the index,
	# while cleaning the index from the files removed from the working tree;
	# this cleaning will facilite a rebase, because there won't be any conlfict
	# due to an "unclean" working directory (not in sync with the index).
	# The unwip will restore the deleted files to the working tree.
	wip = !"git add -A; git ls-files --deleted -z | xargs -0 git rm; git commit -m \"wip\""
	unwip = !"git log -n 1 | grep -q -c wip && git reset HEAD~1"

	# Assume: from http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
	# Sometimes we want to change a file in a repo, but never check in your edits.
	# We can't use .gitignore because the file is tracked. We use update-index.
	assume   = update-index --assume-unchanged
	unassume = update-index --no-assume-unchanged
	assumed  = !"git ls-files -v | grep ^h | cut -c 3-"

	# Delete all branches that have already been merged into the master branch.
	master-cleanse = !"git master-cleanse-local && git master-cleanse-remote"

	# Delete all local branches that have been merged into the local master branch.
	master-cleanse-local = !"git branch --merged master | grep  -v '\\*\\|master' | xargs -r -n 1 git branch -d"

	# Delete all remote branches that have been merged into the remote master branch.
	master-cleanse-remote = !"git checkout master && git branch -r --merged | grep -v master | sed 's/origin\\///' | xargs -n 1 git push --delete origin"

	# Publish the current branch by pushing it to the remote "origin",
	# and setting the current branch to track the upstream branch.
	publish = !"git push -u origin $(git branch-name)"

	# Unpublish the current branch by deleting the
	# remote version of the current branch.
	unpublish = !"git push origin :$(git branch-name)"

	# ── Shell scripting aliases ────────────────────────────────

	# Get the current branch name
	branch-name = !"git rev-parse --abbrev-ref HEAD"

	# Get the top level directory, regardless of what subdirectory we're in.
	root = ! pwd

	# Execute shell scripts. Git always runs scripts in the top directory.
	# For example "git exec pwd" will always show you the top directory.
	exec = ! exec

	# ── Maintenance aliases ────────────────────────────────────
	# repacker: repack a repo the way Linus recommends.
	repacker = !git repack -a -d -f --depth=300 --window=300 --window-memory=1g

	# ── Advanced aliases ───────────────────────────────────────
	# Search for a given string in all patches and print commit messages.
	# Posted by Mikko Rantalainen on StackOverflow.
	#
	# Example: search for any commit that adds or removes string "foobar"
	#     git searchcommits foobar
	#
	# Example: search commits for string "foobar" in directory src/lib
	#     git searchcommits foobar src/lib
	#
	# Example: search commits for "foobar", print full diff of commit with 1 line context
	#     git searchcommits foobar --pickaxe-all -U1 src/lib
	searchcommits = !"f() { query=\"$1\"; shift; git log -S\"$query\" \"$@\"; }; f \"$@\""

	# A 'debug' alias to help debugging builtins: when debugging builtins,
	# we use gdb to analyze the runtime state. However, we have to disable
	# the pager, and often we have to call the program with arguments.
	# If the program to debug is a builtin, we use this alias.
	debug = !GIT_PAGER= gdb --args git

	# Calling "interdiff" between commits: if upstream applied a
	# slightly modified patch, and we want to see the modifications,
	# we use the program interdiff of the patchutils package.
	intercommit = !sh -c 'git show "$1" > .git/commit1 && git show "$2" > .git/commit2 && interdiff .git/commit[12] | less -FRS' -

	# Prune all your stale remote branches: there's no way to tell
	# git remote update to prune stale branches, and git remote prune
	# does not understand --all. So here is a shell command to do it.
	prune-all = !git remote | xargs -n 1 git remote prune

	# Thanks to cody cutrer
	cherry-pick-merge = !"bash -c 'git cherry-pick -n -m 1 $0 && \
        git log -1 --pretty=%P $0 | cut -b 42- > .git/MERGE_HEAD && \
        git commit -v'"

	# Thanks to jtolds on stackoverflow
	remote-ref = !"bash -c ' \
        local_ref=$(git symbolic-ref HEAD); \
        local_name=${local_ref##refs/heads/}; \
        remote=$(git config branch.\"#local_name\".remote || echo origin); \
        remote_ref=$(git config branch.\"$local_name\".merge); \
        remote_name=${remote_ref##refs/heads/}; \
        echo remotes/$remote/$remote_name'"

	# Thanks to jtolds on stackoverflow
	rebase-recent = !git rebase -i $(git remote-ref)

	# Use graphviz for display.
	# This produces output that can be displayed using dotty, for example:
	#   $ git graphviz HEAD~100..HEAD~60 | dotty /dev/stdin
	#   $ git graphviz --first-parent master | dotty /dev/stdin
	graphviz = !"f() { echo 'digraph git {' ; git log --pretty='format:  %h -> { %p }' \"$@\" | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; echo '}'; }; f"

	# show a list of every branch and show their latests commit, sorted by last commit
	branch-log = for-each-ref --sort=committerdate refs/heads --format='%(committerdate:iso) %(committerdate:relative)%09%(color:white)%(refname:short)%(color:reset)'
	branch-log-remote = for-each-ref --sort=committerdate refs/remotes --format='%(committerdate:iso) %(committerdate:relative)%09%(color:white)%(refname:short)%(color:reset)'

	whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short

	# find the most recent common ancestor of this branch
	ancestor = !bash -c 'diff --old-line-format='' --new-line-format='' <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | head -1' -

	whats-new     = !sh -c 'git log $1@{1}..$1@{0} "$@"'

	# Branch Diff
	branch-diff = "!f() { head=${1:-HEAD} ; ancestor=`git ancestor master $head` ; git diff $ancestor..$head ; }; f"
	branch-vdiff = "!f() { head=${1:-HEAD} ; ancestor=`git ancestor master $head` ; git diff --name-only $ancestor..$head | xargs diffuse -s -r $ancestor ; }; f &"
